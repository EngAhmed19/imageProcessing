import numpy as np
import cv2


class Mask:
	def __init__(self, image: np.ndarray):
		self.image = image

	def apply_mask(self, shape_type="circle", opacity=0.5):
		"""
		Apply a mask generated by a shape function to the image.

		:param shape_type: A string represent one of the possible masks.
		:param opacity: Opacity of the mask overlay (default 0.5).
		:return: Image with the mask applied.
		"""
		image = self.image
		if shape_type == "circle":
			mask = self.circle_function()
		elif shape_type == "triangle":
			mask = self.tri_function()
		elif shape_type == "heart":
			mask = self.heart_function()
		else:
			raise ValueError("Invalid shape_type")
	


        # Expand the shape of an array
		# -1 refers to "the last axis"
		masked_image = image * np.expand_dims(mask, axis=-1) / 255
		result_image = image * (1 - opacity) + masked_image * opacity
		return masked_image
	    


	def circle_function(self):
		"""
		Generate a circular mask for the image.

		:return: Circular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]

		# if center is None:
		# center = (width // 2, height // 2)
		# if radius is None:
		# radius = min(width, height) // 2

		center = (width // 2, height // 2)
		radius = min(width, height) // 2
		mask = np.zeros((height, width), dtype=np.uint8)
		mask = cv2.circle(mask, center, radius, 255, -1)
		return mask


	def heart_function(self):
		"""
		Generate a heart-shaped mask for the image.

		:return: Heart-shaped mask as a NumPy array.
		"""

		def heart_curve(t):  # NOQA
			x = 16 * (np.sin(t) ** 3)  # NOQA
			y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)  # NOQA
			return x, y

		height, width = self.image.shape[:2]
		t = np.linspace(0, 2 * np.pi, 1000)
		x, y = heart_curve(t)

		# Normalize and scale to fit the image dimensions
		x = ((x - np.min(x)) / (np.max(x) - np.min(x)) * (width - 1)).astype(np.int32)
		y = ((y - np.min(y)) / (np.max(y) - np.min(y)) * (height - 1)).astype(np.int32)
		mask = np.zeros((height, width), dtype=np.uint8)
		points = np.array([list(zip(x, y))], dtype=np.int32)
		cv2.fillPoly(mask, points, 255)
		return mask[::-1, :]


	def tri_function(self):
		"""
		Generate a triangular mask for the image, filling the lower-left triangle.

		:return: Triangular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]
		mask = np.zeros((height, width), dtype=np.uint8)
		points = np.array([
            [width // 2, height // 4],
            [width // 4, 3 * height // 4],
            [3 * width // 4, 3 * height // 4]
        ])
		cv2.fillPoly(mask, [points], 255)
		return mask