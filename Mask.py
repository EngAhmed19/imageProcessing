import numpy as np
import cv2


class Mask:
	def __init__(self, image: np.ndarray):
		self.image = image

	def apply_mask(self, shape_type: str, opacity=0.5, save_as_png=False, output_path="masked_image.png"):
		if shape_type == "circle":
			mask = self.circle_function()
		elif shape_type == "triangle":
			mask = self.tri_function()
		elif shape_type == "heart":
			mask = self.heart_function()
		else:
			raise ValueError("Invalid shape_type")

		image = self.image
		# Ensure the image has an alpha channel
		if self.image.shape[-1] != 4:
			b, g, r = cv2.split(self.image)
			alpha = np.ones((self.image.shape[0], self.image.shape[1]), dtype=np.uint8) * 255
			image = cv2.merge((b, g, r, alpha))

		# Apply the mask to the alpha channel
		alpha_channel = image[:, :, 3]
		alpha_channel[mask == 0] = 0
		image[:, :, 3] = alpha_channel

		return image

	def circle_function(self):
		"""
		Generate a circular mask for the image.

		:return: Circular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]

		# if center is None:
		# center = (width // 2, height // 2)
		# if radius is None:
		# radius = min(width, height) // 2

		center = (width // 2, height // 2)
		radius = min(width, height) // 2
		mask = np.zeros((height, width), dtype=np.uint8)
		mask = cv2.circle(mask, center, radius, 255, -1)  # NOQA
		return mask

	def heart_function(self):
		"""
		Generate a heart-shaped mask for the image.

		:return: Heart-shaped mask as a NumPy array.
		"""

		def heart_curve(t):  # NOQA
			x = 16 * (np.sin(t) ** 3)  # NOQA
			y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)  # NOQA
			return x, y

		height, width = self.image.shape[:2]
		t = np.linspace(0, 2 * np.pi, 1000)
		x, y = heart_curve(t)

		# Normalize and scale to fit the image dimensions
		x = ((x - np.min(x)) / (np.max(x) - np.min(x)) * (width - 1)).astype(np.int32)
		y = ((y - np.min(y)) / (np.max(y) - np.min(y)) * (height - 1)).astype(np.int32)
		mask = np.zeros((height, width), dtype=np.uint8)
		points = np.array([list(zip(x, y))], dtype=np.int32)
		cv2.fillPoly(mask, points, 255)  # NOQA
		return mask[::-1, :]

	def tri_function(self):
		"""
		Generate a triangular mask for the image, filling the lower-left triangle.

		:return: Triangular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]
		mask = np.zeros((height, width), dtype=np.uint8)
		points = np.array([
			[width // 2, height // 4],
			[width // 4, 3 * height // 4],
			[3 * width // 4, 3 * height // 4]
		])
		cv2.fillPoly(mask, [points], 255)  # NOQA
		return mask


"""
	def apply_mask(self, shape_type="circle", opacity=0.5):
		
		Apply a mask generated by a shape function to the image.

		:param shape_type: A string represent one of the possible masks.
		:param opacity: Opacity of the mask overlay (default 0.5).
		:return: Image with the mask applied.
		
		image = self.image
		if shape_type == "circle":
			mask = self.circle_function()
		elif shape_type == "triangle":
			mask = self.tri_function()
		elif shape_type == "heart":
			mask = self.heart_function()
		else:
			raise ValueError("Invalid shape_type")

		# Expand the shape of an array
		# -1 refers to "the last axis"
		masked_image = image * np.expand_dims(mask, axis=-1) / 255
		result_image = image * (1 - opacity) + masked_image * opacity
		return masked_image
"""
