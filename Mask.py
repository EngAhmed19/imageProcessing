import numpy as np


class Mask:
    def __init__(self, image: np.ndarray):
        self.image = image

    def apply_mask(self, shape_function, opacity=0.5):
        """
        Apply a mask generated by a shape function to the image.

        :param shape_function: A callable that generates a mask.
        :param opacity: Opacity of the mask overlay (default 0.5).
        :return: Image with the mask applied.
        """
        image = self.image
        mask = shape_function()
        # Expand the shape of an array
        # -1 refers to "the last axis"
        masked_image = image * np.expand_dims(mask, axis=-1) // 255
        result_image = (image * (1 - opacity) + masked_image * opacity).astype(np.uint8)
        return result_image

    def circle_function(self, center=None, radius=None):
        """
        Generate a circular mask for the image.

        :param center: Tuple (x, y) specifying the circle center (optional).
        :param radius: Radius of the circle (optional).
        :return: Circular mask as a NumPy array.
        """
        height, width = self.image.shape[:2]
        if center is None:
            center = (width // 2, height // 2)
        if radius is None:
            radius = min(width, height) // 2

        y, x = np.ogrid[:height, :width]
        distance = np.sqrt((x - center[0]) ** 2 + (y - center[1]) ** 2)
        mask = (distance <= radius).astype(np.uint8) * 255
        return mask

    def heart_function(self):
        """
        Generate a heart-shaped mask for the image.

        :return: Heart-shaped mask as a NumPy array.
        """
        def heart_curve(t):
            x = 16 * (np.sin(t) ** 3)
            y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)
            return x, y

        height, width = self.image.shape[:2]
        t = np.linspace(0, 2 * np.pi, 1000)
        x, y = heart_curve(t)

        # Normalize and scale to fit the image dimensions
        x = ((x - np.min(x)) / (np.max(x) - np.min(x)) * (width - 1)).astype(np.int32)
        y = ((y - np.min(y)) / (np.max(y) - np.min(y)) * (height - 1)).astype(np.int32)

        mask = np.zeros((height, width), dtype=np.uint8)
        for i in range(len(x) - 1):
            mask[y[i], x[i]] = 255

        return np.maximum.accumulate(mask[::-1, :], axis=0)
    def tri_function(self):
        """
		Generate a triangular mask for the image, filling the lower-left triangle.

		:return: Triangular mask as a NumPy array.
		"""
        height, width = self.image.shape[:2]
        mask = np.zeros((height, width), dtype=np.uint8)

		# Define the triangle region
        # -1 argument shifts the diagonal slightly,
        # ensuring the triangle starts at (0, 0)
        y, x = np.tri(height, width, -1, dtype=bool).nonzero()

	    # Fill the mask for the lower-left triangle 
        mask[y, x] = 255
        return mask





