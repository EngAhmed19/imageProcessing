import numpy as np


class Mask:
	def __init__(self, image: np.ndarray):
		self.image = image

	def apply_mask(self, shape_type="circle", opacity=0.5):
		"""
		Apply a mask generated by a shape function to the image.

		:param shape_type: A string represent one of the possible masks.
		:param opacity: Opacity of the mask overlay (default 0.5).
		:return: Image with the mask applied.
		"""
		image = self.image
		if shape_type == "circle":
			mask = self.circle_function()
		elif shape_type == "triangle":
			mask = self.tri_function()
		elif shape_type == "heart":
			mask = self.heart_function()
		else:
			raise ValueError("Invalid shape_type")

		# Expand the shape of an array
		# -1 refers to "the last axis"
		masked_image = image * np.expand_dims(mask, axis=-1) / 255
		result_image = (image * (1 - opacity) + masked_image * opacity).astype(np.uint8)
		return masked_image

	def circle_function(self):
		"""
		Generate a circular mask for the image.

		:return: Circular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]

		# if center is None:
		# center = (width // 2, height // 2)
		# if radius is None:
		# radius = min(width, height) // 2

		center = (width // 2, height // 2)
		radius = min(width, height) // 2

		y, x = np.ogrid[:height, :width]
		distance = np.sqrt((x - center[0]) ** 2 + (y - center[1]) ** 2)
		mask = (distance <= radius).astype(np.uint8) * 255
		return mask

	def heart_function(self):
		"""
		Generate a heart-shaped mask for the image.

		:return: Heart-shaped mask as a NumPy array.
		"""

		def heart_curve(t):  # NOQA
			x = 16 * (np.sin(t) ** 3)  # NOQA
			y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)  # NOQA
			return x, y

		height, width = self.image.shape[:2]
		t = np.linspace(0, 2 * np.pi, 1000)
		x, y = heart_curve(t)

		# Normalize and scale to fit the image dimensions
		x = ((x - np.min(x)) / (np.max(x) - np.min(x)) * (width - 1)).astype(np.int32)
		y = ((y - np.min(y)) / (np.max(y) - np.min(y)) * (height - 1)).astype(np.int32)

		mask = np.zeros((height, width), dtype=np.uint8)
		for i in range(len(x) - 1):
			mask[y[i], x[i]] = 255

		# mask[::-1, :] reversing the rows
		# np.maximum.accumulate(arr, axis=0) performs a cumulative maximum operation along the specified axis (rows)
		# [0, 0, 255, 0, 0]
		# [0, 0, 255, 255, 255]
		return np.maximum.accumulate(mask[::-1, :], axis=0)

	def tri_function(self):
		"""
		Generate a triangular mask for the image, filling the lower-left triangle.

		:return: Triangular mask as a NumPy array.
		"""
		height, width = self.image.shape[:2]
		mask = np.zeros((height, width), dtype=np.uint8)

		# Define the triangle region
		# -1 argument shifts the diagonal slightly,
		# ensuring the triangle starts at (0, 0)
		y, x = np.tri(height, width, -1, dtype=bool).nonzero()

		# Fill the mask for the lower-left triangle
		mask[y, x] = 255
		return mask
